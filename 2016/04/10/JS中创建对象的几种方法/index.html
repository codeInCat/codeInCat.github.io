<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="创建对象的几种方法">
  <meta name="author" content="刘鑫磊">
  <!-- Open Graph Data -->
  <meta property="og:title" content="JS中创建对象的几种方法"/>
  <meta property="og:description" content="创建对象的几种方法" />
  <meta property="og:site_name" content="小猫的前端学习日记"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://yoursite.comundefined"/>
  
    <link rel="alternate" href="/atom.xml" title="小猫的前端学习日记" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>小猫的前端学习日记</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">JS中创建对象的几种方法</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/codeInCat">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:18745764313@163.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>


<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By 刘鑫磊</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2016-04-10</span>
            <span class="time">14:20:37</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/JavaScript/">JavaScript</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/面向对象/">#面向对象</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h1 id="JS中创建对象的几种方法"><a href="#JS中创建对象的几种方法" class="headerlink" title="JS中创建对象的几种方法"></a>JS中创建对象的几种方法</h1><h4 id="1-字面量方式创建对象"><a href="#1-字面量方式创建对象" class="headerlink" title="1.字面量方式创建对象"></a>1.字面量方式创建对象</h4><p><strong>基本写法</strong></p>
<pre>
var  book1 = {
        name:"声名狼藉者的生活",
        price:42.00,
        author:"福柯",
        press:"北京大学出版社",
        read:function () {
            console.log("我的书名为:声名狼藉者的的生活,作者为福柯....");
        }
    };
</pre>
**存在的问题**

`[01] 代码复用性差`

`[02] 如果要创建大量的同类型对象，则需要些大量重复性代码`

#### 2.内置构造函数创建对象

**JS中的内置构造函数**

<pre>
String
Number
Boolean
    注意：(区别于string number boolean)
Date
Array
Function
Object
RegExp
</pre>

<p><strong>基本写法</strong></p>
<pre>
    var book1 = new Object();
    book1.name = "声名狼藉者的生活";
    book1.price = 42.00;
    book1.author = "福柯";
    book1.press = "北京大学出版社";
    book1.read = function () {
        console.log("我的书名为:声名狼藉者的的生活,作者为福柯....");
    };
</pre>

<p><strong>问题</strong></p>
<p><code>01 创建的对象无法复用,复用性差</code></p>
<p><code>02 如果需要创建多个同类型的对象,如(书籍)则需要写大量重复的代码,代码的冗余度高</code></p>
<h4 id="3-工厂函数创建对象"><a href="#3-工厂函数创建对象" class="headerlink" title="3.工厂函数创建对象"></a>3.工厂函数创建对象</h4><p><strong>基本写法</strong></p>
<pre>
    function createBookNew (name,price,author,press) {

        var book = new Object();
        book.name = name;
        book.price = price;
        book.author = author;
        book.press = press;
        book.read = function () {
            console.log("我的书名为:"+book.name+",作者为"+book.author+"....");
        };

        return book;
    }

    //使用工厂函数来创建对象
    var book1 = createBookNew("声名狼藉者的的生活","42.00","福柯","北京大学出版社");
    var book2 = createBookNew("人性的枷锁","49.00","毛姆","华东师范大学出版社");
    var book3 = createBookNew("悟空传","28.00","今何在","湖南文艺出版社");

    //打印对象的属性,调用对象的方法
    console.log(book1.name);
    console.log(book2.name);
    console.log(book3.name);

    book1.read();
    book2.read();
    book3.read();
</pre>

<p><strong>工厂函数说明</strong></p>
<p><code>工厂函数方式创建对象其本质是对内置构造函数创建对象的过程进行了封装</code></p>
<p><code>适用于大规模“批量生产”同类型的对象</code></p>
<pre>
    function createBook (name,price,author,press) {

        //001 参数 = 原料
        var book = new Object();

        //002 创建对象并设置对象的属性和方法 = 对原料进行加工
        book.name = name;
        book.price = price;
        book.author = author;
        book.press = press;
        book.read = function () {
            console.log("我的书名为:"+book.name+",作者为"+book.author+"....");
        };

        //003 把处理好的对象返回给我们 == 产品出厂
        return book;
    }
</pre>

<p><strong>封装思路</strong></p>
<p>使用函数把固定不变的部分封装起来，变化的部分提取为函数的参数</p>
<p><strong>工厂函数创建对象的实现过程</strong></p>
<p><code>① 提供一个创建对象的函数（参数）</code></p>
<p><code>② 在该函数内部使用new关键字和Object构造器创建对象</code></p>
<p><code>③ 设置对象的属性</code></p>
<p><code>④ 设置对象的方法</code></p>
<p><code>⑤ 返回对象</code></p>
<h4 id="4-自定义构造函数创建对象"><a href="#4-自定义构造函数创建对象" class="headerlink" title="4.自定义构造函数创建对象"></a>4.自定义构造函数创建对象</h4><p><strong>基本写法</strong></p>
<pre>
    function 构造函数名(参数1,参数2,参数3...) {
        //设置对象的属性
        this.属性01 = 参数1;
        this.属性02 = 参数2;

        //设置对象的方法
        this.方法01 = function () {
            //.....
        };
        this.方法02 = function () {
            //.....
        }
    }

    //自定义构造函数方式创建对象
    var 对象01 = new 构造函数名(实参01,实参02,实参03...);
    var 对象02 = new 构造函数名(实参01,实参02,实参03...);
</pre>

<p><strong>代码示例</strong></p>
<pre>
    function CreateBook (name,price,author,press) {
        this.name = name;
        this.price = price;
        this.author = author;
        this.press = press;
        this.read = function () {
            console.log("我的书名为:"+this.name+",作者为"+this.author+"....");
        };
    }

    var b1 = new CreateBook("声名狼藉者的的生活","42.00","福柯","北京大学出版社");
    var b2 = new CreateBook("人性的枷锁","49.00","毛姆","华东师范大学出版社");
    var b3 = new CreateBook("悟空传","28.00","今何在","湖南文艺出版社");

    //打印对象的属性,并调用对象的方法测试
    console.log(b1.author);
    console.log(b2.author);
    console.log(b3.author);
    b1.read();
    b2.read();
    b3.read();
</pre>

<p><strong>构造函数与new关键字</strong></p>
<p>构造函数和普通函数的区别：函数的首字母大写</p>
<p>构造函数的作用:用于完成对象的初始化</p>
<p>new关键字的作用：用于创建对象（Object类型）</p>
<p><strong>自定义构造函数和简单工厂函数的对比</strong></p>
<ul>
<li>函数的首字母大写(用于区别构造函数和普通函数)</li>
<li>创建对象的过程是由new关键字实现</li>
<li>在构造函数内部会自动的创建新对象,并赋值给this指针</li>
<li>自动返回创建出来的对象</li>
</ul>
<p><strong>构造函数的执行过程</strong></p>
<p><code>① 使用new关键字创建对象</code></p>
<p><code>② 把新创建出来的对象赋值给this</code></p>
<p><code>③ 在构造函数内部,使用this为新创建出来的对象设置属性和方法</code></p>
<p><code>④ 默认返回新创建的对象(普通函数如果不显式的return则默认返回undefined)。</code></p>
<p><strong>构造函数的返回值</strong></p>
<p>01 如果在构造函数中没有显式的return,则默认返回的是新创建出来的对象</p>
<p>02 如果在构造函数中显示的return,则依照具体的情况处理</p>
<pre><code>[01] return 的是对象,则直接返回该对象,取而代之本该默认返回的新对象
[02] return 的是null或基本数据类型值,则返回新创建的对象
</code></pre><p><strong>构造函数方式创建对象存在的问题</strong></p>
<p><code>每次创建对象,都会重新创建函数，那么如果创建的对象数量很多,而对象方法内部的实现一模一样,则造成了资源浪费</code></p>
<h4 id="构造函数的使用注意"><a href="#构造函数的使用注意" class="headerlink" title="构造函数的使用注意"></a>构造函数的使用注意</h4><p><strong>函数传值</strong></p>
<p><code>函数传值：可以把构造函数的对象方法抽取为参数</code></p>
<p>代码示例</p>
<pre>
    //001 创建一个构造函数
    function Person(name,age,toDoSomeThing) {
        //002 在构造函数内部设置对象的属性和方法
        this.name = name;
        this.age = age;

        this.sayName = function () {
            console.log(this.name);
        };

        this.toDoSomeThing = toDoSomeThing;
    }

    //003 使用构造函数创建对象
    var zhangsan = new Person("张三",18,function () {
        console.log("张三在读书");
    });

    var lisi = new Person("李四",20,function () {
        console.log("李四在玩耍");
    });
</pre>

<p><strong>对象类型</strong></p>
<p><code>检查对象的类型：instanceOf</code><br><code>获取对象的类型：Object.prototype.toString.call(dog)</code></p>
<p><strong>对象的构造器属性</strong></p>
<pre>
function Dog(name) {
        this.name = name;
        this.color = "黄色";
    }
console.log(dog.constructor);
</pre>
`属性的名称：constructor`

`属性的作用：指向创建该对象的构造函数，类似于现实生活中所有的产品都标有生产厂家一样`

**构造函数的调用**

01 构造函数可以像普通函数一样不通过new关键字直接调用

02 在使用构造函数创建对象的时候，如果没有传递参数，则（）可以省略

代码示例:

<pre>
    //01 创建构造函数
    function Person() {
        this.name = "张三";
        this.age = 20;
        this.sayName = function () {
            console.log(this.name);
        }
    }

    //02 使用构造函数创建对象
    var p1 = new Person();
    var p2 = new Person;    //说明:如果不需要传递参数,则在调用构造函数的时候()可以省略
</pre>

<p><strong>this</strong></p>
<p>01 如果使用new 构造函数的方式调用，则this指向内部默认创建出来的空对象</p>
<p>02 如果像调用普通函数一样调用构造函数，则this指向全局对象window(<code>不要这样使用</code>)</p>
<h4 id="5-原型对象"><a href="#5-原型对象" class="headerlink" title="5.原型对象"></a>5.原型对象</h4><p><strong>原型对象概念</strong></p>
<pre><code>在构造函数创建出来的时候,系统会默认帮构造函数创建并关联的一个新对象
自定义构造函数的原型对象默认是一个空对象。
</code></pre><p><strong>原型对象的作用</strong></p>
<pre><code>构造函数中的原型对象中的属性和方法可以被使用该构造函数创建出来的对象使用。
即以自定义构造函数方式创建出来的所有对象,自动拥有和共享该构造函数的原型对象中的所有属性和方法。
</code></pre><p><strong>如何访问构造函数的原型对象</strong></p>
<p>① <code>构造函数.protoType</code></p>
<p>② <code>实例对象.__proto__（不推荐）</code></p>
<p><strong>设置原型对象的属性和方法</strong></p>
<p>① <code>利用对象的动态特性来为构造函数的原型对象添加属性和方法</code></p>
<p>② <code>替换原型对象</code></p>
<h5 id="原型对象的使用注意"><a href="#原型对象的使用注意" class="headerlink" title="原型对象的使用注意"></a>原型对象的使用注意</h5><p><strong>实例和实例化</strong></p>
<p><code>实例化</code>:通过构造函数创建具体对象的过程。</p>
<p><code>实例</code>:通过构造函数实例化出来的对象,我们称之为该构造函数的一个实例。</p>
<p><strong>原型的使用方法</strong></p>
<p>① <code>利用对象的动态特性给原型添加属性|方法</code></p>
<pre>
如果要添加的方法过多,则有大量重复代码
</pre>

<p>② <code>直接替换原型对象</code></p>
<pre>
01 替换前后创建的对象所指向的原型对象不一致  
02 替换原型对象会切断和之前的原型对象之间的关系
</pre>

<p><strong>原型对象的使用注意</strong></p>
<pre>
    ① 访问属性:构造函数创建出来的对象在访问属性的时候,会先在实例内查找,如果没有找到则进一步到对应的原型对象中查找
    ② 设置属性:
       在使用点语法进行赋值的时候,无法操作到对应的原型对象
           如果该属性在对象中已经存在,则修改该属性的值
           如果该属性在对象中尚未存在,则新增该属性
    ③ 设置原型对象的属性:
        [01] 设置原型对象的属性,只能通过构造函数.Prototype的方式|替换原型对象的方式设置
        [02] 如果原型对象的属性是值类型,那么只能通过Person.prototype.属性的方式修改其值
             如果原型对象的属性是引用类型,那么可以通过对象名.引用对象.属性名的方式设置|修改
                (1) 使用构造函数创建出来的多个对象的原型对象中的该属性指向的是同一块数据
                (2) 某个对象对该原型对象属性进行了修改会影响到其他的对象

</pre>
__proto__属性说明

<pre>
    __proto__是一个非标准属性
    即ECMAScript中并不包含该属性,这只是某些浏览器为了方便开发人员开发和调试而提供的一个属性,不具备通用性
    建议:在调试的时候可以使用该属性,但不能出现在正式的代码中
</pre>









        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

